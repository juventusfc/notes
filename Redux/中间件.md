# Middleware

## 新需求：记录每次 action 和更新后的 state

### 方法 1： 手动记录

```javascript
// 原来代码
store.dispatch(addTodo("Use Redux"));

// 手动记录代码
console.log("dispatching", action);
store.dispatch(action);
console.log("next state", store.getState());
```

### 方法 2： 包装 dispacth

```javascript
function dispatchAndLog(store, action) {
  console.log("dispatching", action);
  store.dispatch(action);
  console.log("next state", store.getState());
}
dispatchAndLog(store, addTodo("Use Redux"));
```

### 方法 3： Monkeypatching Dispatch

相当于重写`store.dispatch`

```javascript
const next = store.dispatch;
store.dispatch = function dispatchAndLog(action) {
  console.log("dispatching", action);
  let result = next(action);
  console.log("next state", store.getState());
  return result;
};
```

### 又增加一个新需求：记录 action 出错的详细信息

```javascript
function patchStoreToAddLogging(store) {
  const next = store.dispatch
  store.dispatch = function dispatchAndLog(action) {
    console.log('dispatching', action)
    let result = next(action)
    console.log('next state', store.getState())
    return result
  }
}
​
function patchStoreToAddCrashReporting(store) {
  const next = store.dispatch
  store.dispatch = function dispatchAndReportErrors(action) {
    try {
      return next(action)
    } catch (err) {
      console.error('Caught an exception!', err)
      Raven.captureException(err, {
        extra: {
          action,
          state: store.getState()
        }
      })
      throw err
    }
  }
}
// 调用。传入的store就有了新的dispatch方法。
patchStoreToAddLogging(store)
patchStoreToAddCrashReporting(store)
```

### 方法 4：Hiding Monkeypatching

针对 logger，我们可以根据上面的代码改写为：

```javascript
function logger(store) {
  const next = store.dispatch
​
  // Previously:
  // store.dispatch = function dispatchAndLog(action) {
​
  return function dispatchAndLog(action) {
    console.log('dispatching', action)
    let result = next(action)
    console.log('next state', store.getState())
    return result
  }
}
```

更优雅的方式是使用一个 helper：

```javascript
function applyMiddlewareByMonkeypatching(store, middlewares) {
  middlewares = middlewares.slice()
  middlewares.reverse()
​
  // Transform dispatch function with each middleware.
  middlewares.forEach(middleware =>
    store.dispatch = middleware(store)
  )
}
// 调用
applyMiddlewareByMonkeypatching(store, [logger, crashReporter])
```

### 方法 5： Removing Monkeypatching

以上的 logger 还可以传入 next 以接受上一次 store.dispatch 所指的函数。es6 提供的箭头函数能使代码更直观易懂。

```javascript
function logger(store) {
  return function wrapDispatchToAddLogging(next) {
    return function dispatchAndLog(action) {
      console.log("dispatching", action);
      let result = next(action);
      console.log("next state", store.getState());
      return result;
    };
  };
}

// es6
const logger = store => next => action => {
  console.log("dispatching", action);
  let result = next(action);
  console.log("next state", store.getState());
  return result;
};
```

### 方法 6： 简易的 Middleware 实现

```javascript
function applyMiddleware(store, middlewares) {
  middlewares = middlewares.slice();
  middlewares.reverse();
  let dispatch = store.dispatch;
  middlewares.forEach(middleware => (dispatch = middleware(store)(dispatch)));
  return Object.assign({}, store, { dispatch });
}
```

## 总结

中间件

```javascript
const logger = store => next => action => {
  console.log('dispatching', action)
  let result = next(action)
  console.log('next state', store.getState())
  return result
}
​
const crashReporter = store => next => action => {
  try {
    return next(action)
  } catch (err) {
    console.error('Caught an exception!', err)
    Raven.captureException(err, {
      extra: {
        action,
        state: store.getState()
      }
    })
    throw err
  }
}
```

store

```javascript
import { createStore, combineReducers, applyMiddleware } from 'redux'
​
const todoApp = combineReducers(reducers)
const store = createStore(
  todoApp,
  // applyMiddleware() tells createStore() how to handle middleware.使用的不是上面定义的applyMiddleware，是redux包里的。
  applyMiddleware(logger, crashReporter)
)
```
