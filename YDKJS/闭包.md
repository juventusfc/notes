# 闭包

> Closure is when a function is able to remember and access its lexical scope even when that function is executing **outside** its lexical scope.
>
> 当内部函数是在定义它的词法作用域之外（外部函数）执行，仍然可以记住并访问它所在的词法作用域，这时就产生了闭包。

即：一个函数在他定义的 Scope 之外被调用，就是 Closure。

下面的例子中，涉及 3 个作用域：

1. 全局作用域: 其中的变量有 foo
2. foo 作用域：其中的变量有 a 和 bar
3. bar 作用域

bar 的词法作用域是 foo，当执行 `baz()` 时，其实是在全局作用域中执行了 `bar()` ，由于闭包，bar 还能继续访问 foo 中的 a。

```javascript
function foo() {
  var a = 2;

  function bar() {
    console.log(a);
  }

  return bar;
}

var baz = foo(); //bar函数被返回，赋值给baz。baz保留了对foo scope中a的也引用。

baz(); //2 执行baz函数。这意味着在foo scope之外，bar被调用了。bar对foo scope的引用就是closure。closure使得bar能继续调用foo scope中的a。
```

只要使用了回调函数，实际上就是在使用闭包。

```javascript
function wait(message) {
  setTimeout(function timer() {
    // 回调函数中meesage引用了wait函数的message参数，也是一种closure
    console.log(message);
  }, 1000);
}

wait("Hello, closure!");
```
