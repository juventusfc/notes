# 闭包

> Closure is when a function is able to remember and access its lexical scope even when that function is executing **outside** its lexical scope.
>
> 当内部函数是在定义它的词法作用域之外（外部函数）执行，仍然可以记住并访问它所在的词法作用域，这时就产生了闭包。

即：**一个函数**在他定义的词法作用域之外被调用，就是 Closure。

下面的例子中，涉及 3 个作用域：

1. 全局作用域: 其中的变量有 foo 和 baz
2. foo 作用域：其中的变量有 a 和 bar
3. bar 作用域

bar 的词法作用域是 foo，当执行 `baz()` 时，其实是在全局作用域中执行了 `bar()` ，由于闭包，bar 还能继续访问 foo 中的 a。

```javascript
function foo() {
  var a = 2;

  function bar() {
    console.log(a);
  }

  return bar;
}

var baz = foo(); //bar 函数被返回，赋值给 baz。baz 保留了对 foo Scope中 a 的也引用。

baz(); //2。执行 baz 函数。这意味着在 foo Scope 之外，bar 被调用了。bar 在全局作用域被调用就是 closure。closure 使得 bar 能继续调用 foo Scope 中的 a。
```

就是说，只要使用了回调函数，实际上就是在使用闭包。

```javascript
function wait(message) {
  setTimeout(function timer() {
    // 回调函数中meesage引用了wait函数的message参数，也是一种closure
    console.log(message);
  }, 1000);
}

wait("Hello, closure!");
```
